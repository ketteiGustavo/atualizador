name: Atualizar versao_release.txt (COBOL 4.0)

on:
  schedule:
    # Seg–Qui das 09h as 17h
    - cron: "*/20 11-21 * * 1-4"
  workflow_dispatch: {}

permissions:
  contents: write

concurrency:
  group: auto-release
  cancel-in-progress: true

env:
  TZ: America/Sao_Paulo
  PATH_VERSAO_FILE: "Atual/versao_release.txt"
  URL_BASE_VERSAO40:  "https://s3.amazonaws.com/avancoprogramas/integral/versao40-"
  URL_BASE_RELEASE40: "https://s3.amazonaws.com/avancoprogramas/integral/release40-"

jobs:
  auto-update:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Data/hora (BRT) e fim da janela?
        id: dt
        shell: bash
        run: |
          export TZ="${TZ:-America/Sao_Paulo}"
          day=$(date +%Y%m%d)         # ex: 20250819
          hour=$(date +%H)            # 00..23 (BRT)
          is_end=false
          if [ "$hour" -eq 17 ]; then is_end=true; fi  # último horário do dia útil
          echo "day=$day" >> "$GITHUB_OUTPUT"
          echo "hour=$hour" >> "$GITHUB_OUTPUT"
          echo "is_end_of_window=$is_end" >> "$GITHUB_OUTPUT"

      - name: Restaurar estado diário
        id: cache
        uses: actions/cache@v4
        with:
          path: .gha-state
          key: state-${{ steps.dt.outputs.day }}
          # sem restore-keys: 1 cache por dia

      - name: Garantir permissão de execução do script
        run: chmod +x scripts/check_release_first.sh

      - name: Executar verificação
        id: runcheck
        run: |
          export DEBUG_URLS=true
          out="$(./scripts/check_release_first.sh)"
          echo "$out"
          echo "result=$out" >> "$GITHUB_OUTPUT"

      # Se houve alteração, commita direto na main
      - name: Commit & Push se mudou (direto na main)
        if: contains(steps.runcheck.outputs.result, 'CHANGED|')
        run: |
          git config user.name  "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add "${PATH_VERSAO_FILE}"
          git commit -m "chore: atualizar versao_release.txt (auto)"
          git push

      # Interpretar o resultado em variáveis simples (tipo/from/to)
      - name: Interpretar resultado (sempre)
        id: interp
        shell: bash
        run: |
          res="${{ steps.runcheck.outputs.result }}"
          # Formatos esperados:
          #   CHANGED|RELEASE|<old_rel>|<new_rel>
          #   CHANGED|VERSION|<old_ver>|<new_ver>
          #   NOCHANGE|RELEASE_ALREADY_SET
          #   NOCHANGE|NOTHING_FOUND
          status="$(echo "$res" | awk -F'|' '{print $1}')"
          kind_raw="$(echo "$res" | awk -F'|' '{print $2}')"
          from_val="$(echo "$res" | awk -F'|' '{print $3}')"
          to_val="$(echo "$res"   | awk -F'|' '{print $4}')"

          # Mapeia tipo humano e assunto base
          subject=""
          case "$kind_raw" in
            VERSION) kind_human="VERSÃO" ;;
            RELEASE) kind_human="RELEASE" ;;
            RELEASE_ALREADY_SET) kind_human="SEM ALTERAÇÃO (release já registrada)" ;;
            NOTHING_FOUND)       kind_human="SEM ALTERAÇÃO (nenhum release hoje / versão nova não encontrada)" ;;
            *)                   kind_human="$kind_raw" ;;
          esac

          if [[ "$status" == "CHANGED" ]]; then
            subject="Atualização de ${kind_human} no repositório"
          else
            # Ajusta assunto amigável para NOCHANGE
            case "$kind_raw" in
              RELEASE_ALREADY_SET) subject="Verificação: release do dia já registrada" ;;
              NOTHING_FOUND)       subject="Verificação: sem release hoje e sem nova versão" ;;
              *)                   subject="Verificação: nenhuma atualização encontrada" ;;
            esac
          fi

          # Motivo detalhado para NOCHANGE
          reason=""
          if [[ "$status" == "NOCHANGE" ]]; then
            if [[ "$kind_raw" == "RELEASE_ALREADY_SET" ]]; then
              reason="Release do dia já estava registrada no arquivo."
            elif [[ "$kind_raw" == "NOTHING_FOUND" ]]; then
              reason="Nenhum release encontrado hoje e nenhuma nova versão encontrada na janela de 21 dias."
            else
              reason="$kind_raw"
            fi
          fi

          echo "status=${status}"   >> "$GITHUB_OUTPUT"
          echo "kind=${kind_human}" >> "$GITHUB_OUTPUT"
          echo "from=${from_val}"   >> "$GITHUB_OUTPUT"
          echo "to=${to_val}"       >> "$GITHUB_OUTPUT"
          echo "subject=${subject}" >> "$GITHUB_OUTPUT"
          echo "reason=${reason}"   >> "$GITHUB_OUTPUT"

      # Lê SEMPRE o conteúdo atual do arquivo (para incluir no e-mail)
      - name: Ler arquivo versao_release.txt
        id: file
        shell: bash
        run: |
          echo 'content<<EOF' >> $GITHUB_OUTPUT
          cat "${PATH_VERSAO_FILE}" >> $GITHUB_OUTPUT
          echo 'EOF' >> $GITHUB_OUTPUT

      # === E-mails com anti-spam de "mesmo dia" via flags no cache ===

      # Enviar SOMENTE a 1ª vez que mudar no dia (se já enviou, não repete)
      - name: Enviar e-mail (mudou hoje - primeira vez)
        if: contains(steps.runcheck.outputs.result, 'CHANGED|') && hashFiles('.gha-state/changed.flag') == ''
        continue-on-error: true
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: ${{ secrets.SMTP_HOST }}
          server_port:    ${{ secrets.SMTP_PORT }}
          username:       ${{ secrets.SMTP_USERNAME }}
          password:       ${{ secrets.SMTP_PASSWORD }}
          to:             ${{ secrets.TO_EMAIL }}
          from:           ${{ secrets.FROM_EMAIL }}
          secure:         false
          subject: ${{ steps.interp.outputs.subject }}
          body: |
            Execução do workflow de atualização do arquivo **Atual/versao_release.txt**.

            Status: ${{ steps.interp.outputs.status }}
            Tipo:   ${{ steps.interp.outputs.kind }}

            Alteração:
            De → ${{ steps.interp.outputs.from }}
            Para → ${{ steps.interp.outputs.to }}

            Conteúdo atual do arquivo:
            ${{ steps.file.outputs.content }}

      - name: Marcar que já enviou e-mail de mudança hoje
        if: contains(steps.runcheck.outputs.result, 'CHANGED|') && hashFiles('.gha-state/changed.flag') == ''
        shell: bash
        run: |
          mkdir -p .gha-state
          echo "sent $(date)" > .gha-state/changed.flag

      # Enviar NOCHANGE apenas no último horário do dia útil
      # …e só se NÃO houve mudança hoje, e ainda não mandamos NOCHANGE.
      - name: Enviar e-mail (NOCHANGE no fim do dia)
        if: contains(steps.runcheck.outputs.result, 'NOCHANGE|')
            && steps.dt.outputs.is_end_of_window == 'true'
            && hashFiles('.gha-state/changed.flag') == ''
            && hashFiles('.gha-state/nochange.flag') == ''
        continue-on-error: true
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: ${{ secrets.SMTP_HOST }}
          server_port:    ${{ secrets.SMTP_PORT }}
          username:       ${{ secrets.SMTP_USERNAME }}
          password:       ${{ secrets.SMTP_PASSWORD }}
          to:             ${{ secrets.TO_EMAIL }}
          from:           ${{ secrets.FROM_EMAIL }}
          secure:         false
          subject: ${{ steps.interp.outputs.subject }}
          body: |
            Execução do workflow de atualização do arquivo **Atual/versao_release.txt**.

            Status: ${{ steps.interp.outputs.status }}
            Motivo: ${{ steps.interp.outputs.reason }}

            Conteúdo atual do arquivo:
            ${{ steps.file.outputs.content }}

      - name: Marcar que já enviou NOCHANGE hoje
        if: contains(steps.runcheck.outputs.result, 'NOCHANGE|')
            && steps.dt.outputs.is_end_of_window == 'true'
            && hashFiles('.gha-state/changed.flag') == ''
            && hashFiles('.gha-state/nochange.flag') == ''
        shell: bash
        run: |
          mkdir -p .gha-state
          echo "sent $(date)" > .gha-state/nochange.flag